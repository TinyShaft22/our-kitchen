---
phase: 28-cooking-mode
plan: 04
type: execute
wave: 2
depends_on: ["28-01"]
files_modified:
  - our-kitchen-alexa/lambda/interceptors/ResponseInterceptors.js
  - our-kitchen-alexa/lambda/interceptors/RequestInterceptors.js
  - our-kitchen-alexa/lambda/index.js
  - our-kitchen-alexa/lambda/handlers/CookingHandlers.js
autonomous: true

must_haves:
  truths:
    - "Cooking progress persists to DynamoDB when user leaves mid-recipe"
    - "User can resume cooking where they left off on next session"
    - "LaunchRequestHandler offers to resume if cooking progress exists"
    - "Completing or exiting a recipe clears the cooking progress"
  artifacts:
    - path: "our-kitchen-alexa/lambda/interceptors/ResponseInterceptors.js"
      provides: "Cooking progress auto-save interceptor"
      exports: ["SavePersistentAttributesInterceptor"]
    - path: "our-kitchen-alexa/lambda/interceptors/RequestInterceptors.js"
      provides: "Cooking progress load on session start"
      exports: ["LoadHouseholdInterceptor"]
    - path: "our-kitchen-alexa/lambda/index.js"
      provides: "Updated LaunchRequestHandler with resume detection"
      contains: "cookingProgress"
  key_links:
    - from: "our-kitchen-alexa/lambda/interceptors/ResponseInterceptors.js"
      to: "DynamoDB"
      via: "savePersistentAttributes with cookingProgress"
      pattern: "cookingProgress"
    - from: "our-kitchen-alexa/lambda/index.js"
      to: "persistent cookingProgress"
      via: "LaunchRequestHandler checks for in-progress cooking"
      pattern: "cookingProgress.*recipeId"
---

<objective>
Add persistent cooking progress using DynamoDB so users can resume mid-recipe after leaving the skill.

Purpose: Users cooking with messy hands may exit accidentally or the session may timeout. They should be able to return and continue from where they left off, not restart from the beginning.

Output:
- ResponseInterceptors saves cookingProgress to persistent attributes
- RequestInterceptors loads cookingProgress into session on start
- LaunchRequestHandler detects and offers to resume
- CookingHandlers clears progress on completion/exit
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-cooking-mode/28-CONTEXT.md
@.planning/phases/28-cooking-mode/28-01-SUMMARY.md (after Plan 01 completes)
@our-kitchen-alexa/lambda/interceptors/ResponseInterceptors.js
@our-kitchen-alexa/lambda/interceptors/RequestInterceptors.js
@our-kitchen-alexa/lambda/index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update ResponseInterceptors to save cooking progress</name>
  <files>
    our-kitchen-alexa/lambda/interceptors/ResponseInterceptors.js
  </files>
  <action>
Update SavePersistentAttributesInterceptor to detect cooking mode and persist progress.

**Changes to our-kitchen-alexa/lambda/interceptors/ResponseInterceptors.js:**

The existing interceptor uses a "dirty flag" pattern. We need to also save cooking progress when in cooking mode.

**Add cooking progress detection before the dirty flag check:**

```javascript
const SavePersistentAttributesInterceptor = {
  async process(handlerInput) {
    const sessionAttributes = handlerInput.attributesManager.getSessionAttributes() || {};

    // Check if cooking mode is active - persist progress for resume
    if (sessionAttributes.cookingMode === true && sessionAttributes.cookingRecipe) {
      try {
        const persistentAttributes = await handlerInput.attributesManager.getPersistentAttributes() || {};

        // Store cooking progress
        persistentAttributes.cookingProgress = {
          recipeId: sessionAttributes.cookingRecipe.id || '',
          recipeName: sessionAttributes.cookingRecipe.name || '',
          currentStep: sessionAttributes.cookingStep || 0,
          totalSteps: (sessionAttributes.cookingSteps || []).length,
          householdCode: sessionAttributes.householdCode || '',
          timestamp: Date.now()
        };

        handlerInput.attributesManager.setPersistentAttributes(persistentAttributes);
        await handlerInput.attributesManager.savePersistentAttributes();
        console.log('Saved cooking progress:', persistentAttributes.cookingProgress.recipeName,
          'step', persistentAttributes.cookingProgress.currentStep);
      } catch (error) {
        console.error('Failed to save cooking progress:', error.message);
      }
    }

    // Existing dirty flag save logic
    if (sessionAttributes.persistentAttributesDirty) {
      try {
        await handlerInput.attributesManager.savePersistentAttributes();
        console.log('Saved persistent attributes');

        // Clear dirty flag
        sessionAttributes.persistentAttributesDirty = false;
        handlerInput.attributesManager.setSessionAttributes(sessionAttributes);
      } catch (error) {
        console.error('Failed to save persistent attributes:', error.message);
      }
    }
  }
};
```

**Key points:**
- Saves on EVERY response while in cooking mode (not just dirty flag)
- Stores: recipeId, recipeName, currentStep, totalSteps, householdCode, timestamp
- Timestamp enables expiry logic (e.g., don't resume if > 24 hours old)
- Existing dirty flag logic remains untouched for other features
  </action>
  <verify>
Verify ResponseInterceptors loads:
```bash
cd our-kitchen-alexa/lambda && node -e "
const { SavePersistentAttributesInterceptor } = require('./interceptors/ResponseInterceptors');
console.log('Interceptor type:', typeof SavePersistentAttributesInterceptor.process);
"
```
  </verify>
  <done>ResponseInterceptors saves cookingProgress to DynamoDB on each response while in cooking mode</done>
</task>

<task type="auto">
  <name>Task 2: Update LaunchRequestHandler to offer resume and add clear progress helper</name>
  <files>
    our-kitchen-alexa/lambda/index.js
  </files>
  <action>
Update LaunchRequestHandler to detect in-progress cooking and offer to resume.

**Changes to our-kitchen-alexa/lambda/index.js:**

**1. Add helper function to clear cooking progress (near top of file, after imports):**

```javascript
/**
 * Clear cooking progress from persistent attributes
 * Called when user completes a recipe or explicitly exits cooking mode
 */
async function clearCookingProgress(handlerInput) {
  try {
    const persistentAttributes = await handlerInput.attributesManager.getPersistentAttributes() || {};
    if (persistentAttributes.cookingProgress) {
      delete persistentAttributes.cookingProgress;
      handlerInput.attributesManager.setPersistentAttributes(persistentAttributes);
      await handlerInput.attributesManager.savePersistentAttributes();
      console.log('Cleared cooking progress');
    }
  } catch (error) {
    console.error('Failed to clear cooking progress:', error.message);
  }
}

// Export for use in CookingHandlers
module.exports.clearCookingProgress = clearCookingProgress;
```

**2. Update LaunchRequestHandler to check for cooking progress:**

```javascript
const LaunchRequestHandler = {
    canHandle(handlerInput) {
        return Alexa.getRequestType(handlerInput.requestEnvelope) === 'LaunchRequest';
    },
    async handle(handlerInput) {
        const sessionAttributes = handlerInput.attributesManager.getSessionAttributes();
        const isLinked = sessionAttributes.isLinked;

        if (isLinked) {
            // Check for in-progress cooking to resume
            try {
                const persistentAttributes = await handlerInput.attributesManager.getPersistentAttributes() || {};
                const cookingProgress = persistentAttributes.cookingProgress;

                // Check if we have valid cooking progress (not expired - 24 hour limit)
                const twentyFourHours = 24 * 60 * 60 * 1000;
                if (cookingProgress &&
                    cookingProgress.recipeId &&
                    cookingProgress.timestamp &&
                    (Date.now() - cookingProgress.timestamp) < twentyFourHours) {

                    // Store resume info in session for ResumeCookingIntentHandler
                    sessionAttributes.pendingCookingResume = cookingProgress;
                    handlerInput.attributesManager.setSessionAttributes(sessionAttributes);

                    const stepDisplay = cookingProgress.currentStep === 0
                        ? "the ingredients"
                        : `step ${cookingProgress.currentStep}`;

                    const speakOutput = `Welcome back! You were making ${cookingProgress.recipeName}, ` +
                        `on ${stepDisplay} of ${cookingProgress.totalSteps}. ` +
                        `Say 'continue cooking' to pick up where you left off, or 'start over' to restart.`;
                    const repromptOutput = "Say 'continue cooking' or 'start over'.";

                    return handlerInput.responseBuilder
                        .speak(speakOutput)
                        .reprompt(repromptOutput)
                        .getResponse();
                }
            } catch (error) {
                console.error('Error checking cooking progress:', error.message);
            }

            // No cooking progress - normal linked user welcome
            const speakOutput = "Welcome back to your kitchen! What would you like to do?";
            const repromptOutput = "Try asking what's for dinner, or what's on the grocery list.";

            return handlerInput.responseBuilder
                .speak(speakOutput)
                .reprompt(repromptOutput)
                .getResponse();
        } else {
            // New user - explain and prompt for PIN
            const speakOutput = "Welcome to Kitchen Helper! To get started, I need to connect to your household. What's your four-digit PIN from the app?";
            const repromptOutput = "Say your four-digit household PIN to link this device.";

            return handlerInput.responseBuilder
                .speak(speakOutput)
                .reprompt(repromptOutput)
                .getResponse();
        }
    }
};
```

**Note:** LaunchRequestHandler must become async since it now reads persistent attributes.
  </action>
  <verify>
Verify index.js loads and clearCookingProgress is exported:
```bash
cd our-kitchen-alexa/lambda && node -e "
const index = require('./index.js');
console.log('clearCookingProgress exported:', typeof index.clearCookingProgress);
"
```
  </verify>
  <done>LaunchRequestHandler detects cooking progress and offers to resume</done>
</task>

<task type="auto">
  <name>Task 3: Add ResumeCookingIntentHandler and update CookingHandlers to clear progress</name>
  <files>
    our-kitchen-alexa/lambda/handlers/CookingHandlers.js
  </files>
  <action>
Add ResumeCookingIntentHandler and update existing handlers to clear progress on completion/exit.

**Changes to our-kitchen-alexa/lambda/handlers/CookingHandlers.js:**

**1. Add import for clearCookingProgress at top:**

```javascript
// Note: clearCookingProgress is exported from index.js
// We'll call it dynamically to avoid circular dependency
```

**2. Add ResumeCookingIntentHandler:**

Handles: "Continue cooking", "Resume", "Pick up where I left off"

```javascript
const ResumeCookingIntentHandler = {
  canHandle(handlerInput) {
    return Alexa.getRequestType(handlerInput.requestEnvelope) === 'IntentRequest'
      && Alexa.getIntentName(handlerInput.requestEnvelope) === 'ResumeCookingIntent';
  },
  async handle(handlerInput) {
    if (!isLinked(handlerInput)) {
      return createPinPromptResponse(handlerInput, 'ResumeCooking');
    }

    const sessionAttributes = handlerInput.attributesManager.getSessionAttributes();
    const pendingResume = sessionAttributes.pendingCookingResume;

    // Check if we have pending resume from LaunchRequest
    if (!pendingResume || !pendingResume.recipeId) {
      return handlerInput.responseBuilder
        .speak("I don't have a recipe to resume. What would you like to cook?")
        .reprompt("Try asking what's for dinner.")
        .getResponse();
    }

    // Fetch the recipe from Firebase
    const householdCode = getHouseholdCode(handlerInput) || pendingResume.householdCode;
    let recipe;
    try {
      recipe = await getRecipe(householdCode, pendingResume.recipeId);
    } catch (error) {
      console.error('Failed to fetch recipe for resume:', error.message);
      return handlerInput.responseBuilder
        .speak("I couldn't find that recipe anymore. What would you like to do?")
        .reprompt("Try asking what's for dinner.")
        .getResponse();
    }

    if (!recipe || !recipe.name) {
      return handlerInput.responseBuilder
        .speak("That recipe seems to have been removed. What would you like to do?")
        .reprompt("Try asking what's for dinner.")
        .getResponse();
    }

    // Parse steps and restore cooking state
    const steps = parseInstructionsToSteps(recipe.instructions || '', recipe.ingredients || []);
    const resumeStep = Math.min(pendingResume.currentStep || 0, steps.length - 1);

    // Store cooking mode state
    sessionAttributes.cookingMode = true;
    sessionAttributes.cookingSteps = steps;
    sessionAttributes.cookingStep = resumeStep;
    sessionAttributes.cookingRecipe = recipe;
    delete sessionAttributes.pendingCookingResume; // Clear pending resume
    handlerInput.attributesManager.setSessionAttributes(sessionAttributes);

    // Build voice output for resumed step
    const step = steps[resumeStep];
    const speakOutput = `Resuming ${recipe.name}. ${step.title}. ${step.content} <break time="300ms"/> Say 'next step' to continue.`;

    const responseBuilder = handlerInput.responseBuilder
      .speak(speakOutput)
      .reprompt("Say 'next step', 'previous step', or 'repeat'.");

    // Add APL if supported
    if (Alexa.getSupportedInterfaces(handlerInput.requestEnvelope)['Alexa.Presentation.APL']) {
      responseBuilder.addDirective({
        type: 'Alexa.Presentation.APL.RenderDocument',
        token: 'cookingStepToken',
        document: cookingStepDocument,
        datasources: buildCookingStepDataSource(recipe, resumeStep)
      });
    }

    return responseBuilder.getResponse();
  }
};
```

**3. Add ExitCookingIntentHandler for explicit exit:**

Handles: "Exit cooking", "Stop cooking", "I'm done cooking"

```javascript
const ExitCookingIntentHandler = {
  canHandle(handlerInput) {
    const sessionAttributes = handlerInput.attributesManager.getSessionAttributes();
    return Alexa.getRequestType(handlerInput.requestEnvelope) === 'IntentRequest'
      && Alexa.getIntentName(handlerInput.requestEnvelope) === 'ExitCookingIntent'
      && sessionAttributes.cookingMode === true;
  },
  async handle(handlerInput) {
    const sessionAttributes = handlerInput.attributesManager.getSessionAttributes();
    const recipe = sessionAttributes.cookingRecipe;

    // Clear cooking mode state
    sessionAttributes.cookingMode = false;
    sessionAttributes.cookingSteps = null;
    sessionAttributes.cookingStep = 0;
    sessionAttributes.cookingRecipe = null;
    handlerInput.attributesManager.setSessionAttributes(sessionAttributes);

    // Clear persistent cooking progress
    try {
      const persistentAttributes = await handlerInput.attributesManager.getPersistentAttributes() || {};
      if (persistentAttributes.cookingProgress) {
        delete persistentAttributes.cookingProgress;
        handlerInput.attributesManager.setPersistentAttributes(persistentAttributes);
        await handlerInput.attributesManager.savePersistentAttributes();
        console.log('Cleared cooking progress on exit');
      }
    } catch (error) {
      console.error('Failed to clear cooking progress:', error.message);
    }

    const recipeName = recipe?.name || 'your recipe';
    return handlerInput.responseBuilder
      .speak(`Exited cooking mode for ${recipeName}. What would you like to do?`)
      .reprompt("Try asking what's for dinner, or what's on the grocery list.")
      .getResponse();
  }
};
```

**4. Update NextStepIntentHandler to clear progress on completion:**

In the isLastStep block, add code to clear the cooking progress:

```javascript
// In NextStepIntentHandler, after setting isLastStep and before speaking:
if (isLastStep && !step.isIngredients) {
  // Clear cooking mode and progress
  sessionAttributes.cookingMode = false;
  sessionAttributes.cookingSteps = null;
  sessionAttributes.cookingRecipe = null;
  handlerInput.attributesManager.setSessionAttributes(sessionAttributes);

  // Clear persistent cooking progress
  try {
    const persistentAttributes = await handlerInput.attributesManager.getPersistentAttributes() || {};
    if (persistentAttributes.cookingProgress) {
      delete persistentAttributes.cookingProgress;
      handlerInput.attributesManager.setPersistentAttributes(persistentAttributes);
      await handlerInput.attributesManager.savePersistentAttributes();
      console.log('Cleared cooking progress on completion');
    }
  } catch (error) {
    console.error('Failed to clear cooking progress:', error.message);
  }

  speakOutput = `${step.content} <break time="500ms"/> You're done! Enjoy your meal.`;
}
```

**Note:** NextStepIntentHandler's handle method must become async.

**5. Update exports:**

```javascript
module.exports = {
  StartCookingIntentHandler,
  NextStepIntentHandler,
  PreviousStepIntentHandler,
  RepeatStepIntentHandler,
  ResumeCookingIntentHandler,
  ExitCookingIntentHandler
};
```
  </action>
  <verify>
Verify CookingHandlers loads with new handlers:
```bash
cd our-kitchen-alexa/lambda && node -e "
const h = require('./handlers/CookingHandlers');
console.log('Exports:', Object.keys(h).join(', '));
"
```
  </verify>
  <done>ResumeCookingIntentHandler and ExitCookingIntentHandler added, NextStepIntentHandler clears progress on completion</done>
</task>

<task type="auto">
  <name>Task 4: Register ResumeCookingIntentHandler and ExitCookingIntentHandler in index.js</name>
  <files>
    our-kitchen-alexa/lambda/index.js
  </files>
  <action>
Update index.js to import and register the new cooking resume/exit handlers.

**Changes to our-kitchen-alexa/lambda/index.js:**

**1. Update the import from CookingHandlers to include new handlers:**

```javascript
const {
  StartCookingIntentHandler,
  NextStepIntentHandler,
  PreviousStepIntentHandler,
  RepeatStepIntentHandler,
  ResumeCookingIntentHandler,
  ExitCookingIntentHandler
} = require('./handlers/CookingHandlers');
```

**2. Add the new handlers to addRequestHandlers():**

Place ResumeCookingIntentHandler near the top (after LaunchRequestHandler) since it handles post-launch resume flow.
Place ExitCookingIntentHandler with the other cooking handlers.

```javascript
.addRequestHandlers(
    LaunchRequestHandler,
    ResumeCookingIntentHandler,       // NEW - handles "continue cooking" after launch
    LinkHouseholdIntentHandler,
    BrowseMealsIntentHandler,
    GetRecipeIntentHandler,
    BrowseCategoryIntentHandler,
    StartCookingIntentHandler,
    NextStepIntentHandler,
    PreviousStepIntentHandler,
    RepeatStepIntentHandler,
    ExitCookingIntentHandler,         // NEW - handles "exit cooking" / "stop cooking"
    ReadGroceryListIntentHandler,
    AddGroceryIntentHandler,
    UndoGroceryIntentHandler,
    RemoveGroceryIntentHandler,
    CheckOffGroceryIntentHandler,
    MealSelectedEventHandler,
    StartCookingEventHandler,
    StepChangedEventHandler,
    ExitCookingModeEventHandler,
    HelloWorldIntentHandler,
    HelpIntentHandler,
    CancelAndStopIntentHandler,
    FallbackIntentHandler,
    SessionEndedRequestHandler
)
```

**Note:** Handler order matters:
- ResumeCookingIntentHandler goes early because it's a direct follow-up to LaunchRequest resume offer
- ExitCookingIntentHandler checks `cookingMode === true` in canHandle, so it only triggers during cooking mode
  </action>
  <verify>
Verify index.js loads and handlers are registered:
```bash
cd our-kitchen-alexa/lambda && node -e "
require('./index.js');
console.log('Lambda loaded with resume/exit handlers');
"
```

Also verify the imports:
```bash
grep "ResumeCookingIntentHandler\|ExitCookingIntentHandler" our-kitchen-alexa/lambda/index.js
```
  </verify>
  <done>ResumeCookingIntentHandler and ExitCookingIntentHandler registered in index.js</done>
</task>

</tasks>

<verification>
All resume functionality integrated:

1. ResponseInterceptors saves cooking progress:
```bash
grep "cookingProgress" our-kitchen-alexa/lambda/interceptors/ResponseInterceptors.js
```

2. LaunchRequestHandler checks for resume:
```bash
grep "cookingProgress\|pendingCookingResume" our-kitchen-alexa/lambda/index.js
```

3. CookingHandlers has Resume and Exit handlers:
```bash
cd our-kitchen-alexa/lambda && node -e "
const h = require('./handlers/CookingHandlers');
console.log('Resume:', typeof h.ResumeCookingIntentHandler);
console.log('Exit:', typeof h.ExitCookingIntentHandler);
"
```

4. index.js imports and registers Resume/Exit handlers:
```bash
grep "ResumeCookingIntentHandler" our-kitchen-alexa/lambda/index.js
grep "ExitCookingIntentHandler" our-kitchen-alexa/lambda/index.js
```

5. Full Lambda validation:
```bash
cd our-kitchen-alexa/lambda && node -e "require('./index.js')"
```
</verification>

<success_criteria>
- Cooking progress saves to DynamoDB on each step change
- LaunchRequestHandler detects expired progress (24h limit)
- "Continue cooking" resumes at the saved step with APL
- "Exit cooking" clears progress explicitly
- Completing recipe clears progress automatically
- ResumeCookingIntentHandler and ExitCookingIntentHandler registered in index.js
- Lambda loads successfully
</success_criteria>

<output>
After completion, create `.planning/phases/28-cooking-mode/28-04-SUMMARY.md`
</output>

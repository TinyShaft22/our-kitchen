---
phase: 06-grocery-generation
plan: 01
type: execute
---

<objective>
Create core grocery list generation logic from weekly meal plans.

Purpose: Transform weekly planned meals into a combined grocery list, scaling quantities and merging duplicates.
Output: Utility function for grocery generation + batch generation method in useGroceryList hook.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-phase.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context
@.planning/phases/03-data-layer/03-01-SUMMARY.md
@.planning/phases/03-data-layer/03-02-SUMMARY.md
@.planning/phases/05-weekly-planning/05-03-SUMMARY.md

# Key source files
@src/types/index.ts
@src/hooks/useMeals.ts
@src/hooks/useWeeklyPlan.ts
@src/hooks/useGroceryList.ts

**Tech stack available:** Firebase Firestore, React hooks, TypeScript
**Established patterns:**
- Utility functions in src/utils/
- Hooks return { data, loading, error, methods }
- writeBatch for multi-document operations (see useGroceryList.clearBoughtItems)

**Key data structures:**
- WeeklyMealEntry: { mealId, servings }
- Meal: { id, name, servings, ingredients[], isBaking }
- Ingredient: { name, qty, unit, category, defaultStore }
- GroceryItem: { id, name, qty, unit, category, store, status, source, householdCode }
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create generateGroceryItems utility</name>
  <files>src/utils/generateGroceryItems.ts</files>
  <action>
Create utility function that transforms weekly plan + meals into grocery items:

```typescript
interface GroceryItemInput {
  name: string;
  qty: number;
  unit: string;
  category: Category;
  store: Store;
}

function generateGroceryItems(
  meals: Meal[],
  weeklyEntries: WeeklyMealEntry[]
): GroceryItemInput[]
```

Logic:
1. For each weekly entry, find the meal by mealId
2. Calculate scaling factor: weeklyEntry.servings / meal.servings
3. For each ingredient, scale qty by factor
4. Combine duplicates: same name AND unit â†’ sum quantities
5. Return array of GroceryItemInput (no id/householdCode/status/source - added by hook)

Edge cases:
- Skip entries where meal not found (deleted meal)
- Handle zero/negative servings gracefully
- Case-insensitive name matching for duplicates (normalize to lowercase for comparison, keep original casing)
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Utility function exports generateGroceryItems with proper typing</done>
</task>

<task type="auto">
  <name>Task 2: Add generateFromWeeklyPlan to useGroceryList</name>
  <files>src/hooks/useGroceryList.ts</files>
  <action>
Add method to useGroceryList hook:

```typescript
generateFromWeeklyPlan: (items: GroceryItemInput[]) => Promise<void>
```

Implementation:
1. Delete all existing items where source === 'meal' (use writeBatch like clearBoughtItems)
2. Batch add all new items with:
   - status: 'need'
   - source: 'meal'
   - householdCode from hook closure
3. Commit the batch

Use existing patterns from clearBoughtItems for batch operations. The delete + add should be in the same batch for atomicity.

Export GroceryItemInput type (or import from utils) so callers can use it.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>useGroceryList returns generateFromWeeklyPlan method, batch clears old meal items and adds new ones atomically</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] generateGroceryItems correctly scales and combines ingredients
- [ ] generateFromWeeklyPlan clears old meal-source items before adding new
- [ ] Batch operations are atomic (single commit)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Generation logic ready for UI integration
</success_criteria>

<output>
After completion, create `.planning/phases/06-grocery-generation/06-01-SUMMARY.md`
</output>

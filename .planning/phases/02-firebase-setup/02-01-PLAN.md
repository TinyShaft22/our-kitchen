---
phase: 02-firebase-setup
plan: 01
type: execute
---

<objective>
Initialize Firebase SDK and configure Firestore security rules for household-based access.

Purpose: Establish the backend infrastructure that all data operations depend on.
Output: Working Firebase connection with security rules that protect household data.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-phase.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/SPEC.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@src/App.tsx
@.env.example

**Tech stack available:** Vite, React 19, TypeScript, Tailwind v4, react-router-dom
**Firebase project:** grocery-store-app-c3aa5 (credentials in .env)

**Security rules pattern (from research):**
Household-based access: Store household code in document, use get() to verify requesting user has matching code in localStorage. Since there's no Firebase Auth (just 4-digit code), rules will verify householdCode matches.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Firebase SDK with Firestore</name>
  <files>src/config/firebase.ts, package.json</files>
  <action>
    1. Install firebase package: `npm install firebase`
    2. Create src/config/firebase.ts:
       - Import initializeApp, getFirestore from firebase
       - Read config from import.meta.env (VITE_FIREBASE_* variables)
       - Initialize app and export db (Firestore instance)
       - Export app instance as well
    3. Verify config matches .env.example structure (apiKey, authDomain, projectId, storageBucket, messagingSenderId, appId)

    Avoid: Don't import all of firebase - use modular imports for tree-shaking.
    Avoid: Don't hardcode credentials - use environment variables.
  </action>
  <verify>
    - `npm run build` succeeds without Firebase import errors
    - src/config/firebase.ts exports `db` and `app`
  </verify>
  <done>Firebase SDK initialized with Firestore, modular imports, env-based config</done>
</task>

<task type="auto">
  <name>Task 2: Create Firestore security rules for household access</name>
  <files>firestore.rules</files>
  <action>
    1. Create firestore.rules file at project root
    2. Implement household-based access pattern:
       ```
       rules_version = '2';
       service cloud.firestore {
         match /databases/{database}/documents {
           // Household document - anyone can read to verify code exists
           // Only allow create if code doesn't exist yet
           match /households/{code} {
             allow read: if true;
             allow create: if !exists(/databases/$(database)/documents/households/$(code));
             allow update, delete: if false; // Households are permanent
           }

           // All other collections require matching householdCode field
           match /meals/{mealId} {
             allow read, write: if resource.data.householdCode == request.resource.data.householdCode
                                 || resource == null; // For creates
           }

           match /weeklyMeals/{weekId} {
             allow read, write: if resource.data.householdCode == request.resource.data.householdCode
                                 || resource == null;
           }

           match /groceryList/{itemId} {
             allow read, write: if resource.data.householdCode == request.resource.data.householdCode
                                 || resource == null;
           }

           match /staples/{stapleId} {
             allow read, write: if resource.data.householdCode == request.resource.data.householdCode
                                 || resource == null;
           }

           match /bakingEssentials/{itemId} {
             allow read, write: if resource.data.householdCode == request.resource.data.householdCode
                                 || resource == null;
           }

           match /boughtHistory/{historyId} {
             allow read, write: if resource.data.householdCode == request.resource.data.householdCode
                                 || resource == null;
           }
         }
       }
       ```
    3. The pattern: Each document stores householdCode, queries filter by it

    Note: Since there's no Firebase Auth, we rely on:
    - Client-side localStorage storing the household code
    - All queries including householdCode in the where clause
    - Rules verifying householdCode field matches between existing and new data

    Avoid: Complex get() lookups that count toward read limits
    Avoid: Overly permissive rules - always require householdCode match
  </action>
  <verify>
    - firestore.rules file exists at project root
    - Rules syntax is valid (will be validated on deploy)
  </verify>
  <done>Security rules file created with household-based access pattern for all collections</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] src/config/firebase.ts exports db and app
- [ ] firestore.rules exists with household-based patterns
- [ ] No TypeScript errors
</verification>

<success_criteria>
- Firebase SDK installed and configured
- Firestore instance exportable from src/config/firebase.ts
- Security rules defined for all data collections
- Build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-firebase-setup/02-01-SUMMARY.md`
</output>

---
phase: 35-mark-as-low
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - functions/src/alexa/markAsLow.ts
  - functions/src/alexa/index.ts
  - functions/src/index.ts
  - our-kitchen-alexa/lambda/api/firebaseClient.js
autonomous: true

must_haves:
  truths:
    - "Cloud Function can search baking inventory by item name"
    - "Cloud Function can search household items as fallback"
    - "Baking items get status set to 'low' when marked"
    - "Multiple matches return disambiguation list"
    - "Single match proceeds without asking"
    - "Not found returns helpful response for fallback handling"
  artifacts:
    - path: "functions/src/alexa/markAsLow.ts"
      provides: "Cloud Function endpoint for marking items as low"
      exports: ["markAsLow"]
    - path: "our-kitchen-alexa/lambda/api/firebaseClient.js"
      provides: "Client function for markAsLow"
      contains: "markAsLow"
  key_links:
    - from: "functions/src/alexa/markAsLow.ts"
      to: "bakingEssentials collection"
      via: "Firestore query"
      pattern: "bakingEssentials"
    - from: "functions/src/alexa/markAsLow.ts"
      to: "householdItems collection"
      via: "Firestore query fallback"
      pattern: "householdItems"
    - from: "our-kitchen-alexa/lambda/api/firebaseClient.js"
      to: "Cloud Functions"
      via: "HTTP POST request"
      pattern: "client.post.*markAsLow"
---

<objective>
Create the markAsLow Cloud Function endpoint and Lambda client function for the "mark as low" voice feature.

Purpose: Enable Alexa to mark baking/household items as low stock. The Cloud Function searches baking inventory first (using contains matching for "flour" -> "all-purpose flour"), then falls back to household items. Single matches are marked as low; multiple matches return disambiguation list.

Output: markAsLow Cloud Function, firebaseClient integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/35-mark-as-low/35-CONTEXT.md

Reference patterns:
@functions/src/alexa/lookupHouseholdItem.ts (Cloud Function pattern)
@functions/src/alexa/addGroceryItem.ts (POST pattern)
@functions/src/config.ts (API key pattern)
@our-kitchen-alexa/lambda/api/firebaseClient.js (client pattern)
@src/types/index.ts (BakingEssential type with status: 'stocked' | 'low' | 'out')
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create markAsLow Cloud Function</name>
  <files>
    functions/src/alexa/markAsLow.ts
    functions/src/alexa/index.ts
    functions/src/index.ts
  </files>
  <action>
Create the Cloud Function following the pattern in lookupHouseholdItem.ts:

**functions/src/alexa/markAsLow.ts:**

```typescript
import { onRequest } from "firebase-functions/v2/https";
import { getApps, initializeApp } from "firebase-admin/app";
import { getFirestore } from "firebase-admin/firestore";
import { getApiKey } from "../config";

function ensureInitialized() {
  if (getApps().length === 0) {
    initializeApp();
  }
}

/**
 * POST /markAsLow - Mark a baking/household item as low stock
 *
 * Body: { householdCode: string, item: string, itemId?: string }
 *
 * If itemId is provided, mark that specific item (disambiguation resolved).
 * If not, search for matches:
 *   1. Search bakingEssentials first (contains match on name)
 *   2. Fall back to householdItems (exact match on nameLower)
 *
 * Response:
 *   - Single match: { success: true, markedItem: {...}, source: 'baking'|'household' }
 *   - Multiple matches: { needsDisambiguation: true, matches: [...], source: 'baking' }
 *   - No match: { found: false }
 */
export const markAsLow = onRequest({ cors: true, invoker: "public" }, async (req, res) => {
  ensureInitialized();

  const API_KEY = getApiKey();

  // CORS headers
  res.set("Access-Control-Allow-Origin", "*");
  res.set("Access-Control-Allow-Methods", "POST, OPTIONS");
  res.set("Access-Control-Allow-Headers", "Content-Type, X-API-Key");

  if (req.method === "OPTIONS") {
    res.status(204).send("");
    return;
  }

  if (req.method !== "POST") {
    res.status(405).json({ success: false, error: "Method not allowed" });
    return;
  }

  // Check API key
  const apiKey = req.headers["x-api-key"] || req.query.apiKey;
  if (apiKey !== API_KEY) {
    res.status(401).json({ success: false, error: "Invalid API key" });
    return;
  }

  try {
    const { householdCode, item, itemId } = req.body;

    if (!householdCode || !item) {
      res.status(400).json({ success: false, error: "Missing householdCode or item" });
      return;
    }

    const db = getFirestore();
    const normalizedItem = item.trim().toLowerCase();

    // If itemId provided, mark that specific item (disambiguation resolved)
    if (itemId) {
      const result = await markSpecificItem(db, householdCode, itemId);
      res.status(200).json(result);
      return;
    }

    // Step 1: Search bakingEssentials (contains match)
    const bakingSnapshot = await db.collection("bakingEssentials")
      .where("householdCode", "==", householdCode)
      .get();

    // Filter for contains match (case-insensitive)
    const bakingMatches = bakingSnapshot.docs.filter(doc => {
      const name = doc.data().name?.toLowerCase() || "";
      return name.includes(normalizedItem);
    });

    if (bakingMatches.length === 1) {
      // Single baking match - mark as low
      const doc = bakingMatches[0];
      await doc.ref.update({ status: "low" });

      res.status(200).json({
        success: true,
        markedItem: {
          id: doc.id,
          name: doc.data().name,
          store: doc.data().store,
          status: "low"
        },
        source: "baking"
      });
      return;
    }

    if (bakingMatches.length > 1) {
      // Multiple baking matches - need disambiguation
      const matches = bakingMatches.map(doc => ({
        id: doc.id,
        name: doc.data().name,
        store: doc.data().store
      }));

      res.status(200).json({
        needsDisambiguation: true,
        matches,
        source: "baking"
      });
      return;
    }

    // Step 2: Fall back to householdItems (exact match on nameLower)
    const householdSnapshot = await db.collection("householdItems")
      .where("householdCode", "==", householdCode)
      .where("nameLower", "==", normalizedItem)
      .limit(1)
      .get();

    if (!householdSnapshot.empty) {
      // Found in household items - return info for adding to grocery
      // Note: HouseholdItems don't have a status field, so we just return found
      const doc = householdSnapshot.docs[0];
      const data = doc.data();

      res.status(200).json({
        success: true,
        markedItem: {
          id: doc.id,
          name: data.name,
          store: data.store,
          category: data.category
        },
        source: "household"
      });
      return;
    }

    // Not found in either source
    res.status(200).json({ found: false });

  } catch (error) {
    console.error("markAsLow error:", error);
    res.status(500).json({ success: false, error: "Internal server error" });
  }
});

/**
 * Mark a specific item by ID (after disambiguation)
 */
async function markSpecificItem(
  db: FirebaseFirestore.Firestore,
  householdCode: string,
  itemId: string
): Promise<{ success: boolean; markedItem?: any; source?: string; error?: string }> {
  // Try bakingEssentials first
  const bakingDoc = await db.collection("bakingEssentials").doc(itemId).get();

  if (bakingDoc.exists && bakingDoc.data()?.householdCode === householdCode) {
    await bakingDoc.ref.update({ status: "low" });
    const data = bakingDoc.data();
    return {
      success: true,
      markedItem: {
        id: bakingDoc.id,
        name: data?.name,
        store: data?.store,
        status: "low"
      },
      source: "baking"
    };
  }

  // Try householdItems
  const householdDoc = await db.collection("householdItems").doc(itemId).get();

  if (householdDoc.exists && householdDoc.data()?.householdCode === householdCode) {
    const data = householdDoc.data();
    return {
      success: true,
      markedItem: {
        id: householdDoc.id,
        name: data?.name,
        store: data?.store,
        category: data?.category
      },
      source: "household"
    };
  }

  return { success: false, error: "Item not found" };
}
```

**Update functions/src/alexa/index.ts:**
Add export: `export { markAsLow } from "./markAsLow";`

**Verify functions/src/index.ts:**
The alexa exports should already re-export everything from alexa/index.ts. Confirm markAsLow is accessible.
  </action>
  <verify>
1. File exists: `ls functions/src/alexa/markAsLow.ts`
2. Exported from alexa/index: `grep -n "markAsLow" functions/src/alexa/index.ts`
3. Functions build: `cd functions && npm run build 2>&1 | tail -10`
  </verify>
  <done>markAsLow Cloud Function exists, exports from functions/src/alexa/index.ts, and builds without errors</done>
</task>

<task type="auto">
  <name>Task 2: Add markAsLow to firebaseClient.js</name>
  <files>our-kitchen-alexa/lambda/api/firebaseClient.js</files>
  <action>
Add the markAsLow function to the Lambda's Firebase client:

```javascript
/**
 * Mark an item as low stock
 * @param {string} householdCode - Household identifier
 * @param {string} item - Item name to search for
 * @param {string} [itemId] - Optional specific item ID (for disambiguation)
 * @returns {Promise<Object>} Result with success/needsDisambiguation/found status
 */
async function markAsLow(householdCode, item, itemId = null) {
  const body = { householdCode, item };
  if (itemId) {
    body.itemId = itemId;
  }
  const response = await client.post('/markAsLow', body);
  return response.data;
}
```

Add to module.exports: `markAsLow`
  </action>
  <verify>
1. Function exists: `grep -n "async function markAsLow" our-kitchen-alexa/lambda/api/firebaseClient.js`
2. Exported: `grep -n "markAsLow" our-kitchen-alexa/lambda/api/firebaseClient.js | grep "module.exports"`
  </verify>
  <done>firebaseClient.js exports markAsLow function that calls POST /markAsLow endpoint</done>
</task>

</tasks>

<verification>
1. Cloud Functions build without errors
2. markAsLow returns { success: true, markedItem, source: 'baking' } for single baking match
3. markAsLow returns { needsDisambiguation: true, matches: [...] } for multiple baking matches
4. markAsLow returns { success: true, markedItem, source: 'household' } for household item match
5. markAsLow returns { found: false } when item not found in either source
6. Lambda client can call markAsLow endpoint
</verification>

<success_criteria>
- markAsLow Cloud Function deployed and working
- Baking items get status set to 'low' when marked
- Contains matching works ("flour" matches "all-purpose flour", "bread flour")
- Disambiguation returns multiple matches for handler to present
- Household items fallback works for exact name matches
- Not found returns { found: false } for handler to offer adding anyway
</success_criteria>

<output>
After completion, create `.planning/phases/35-mark-as-low/35-01-SUMMARY.md`
</output>

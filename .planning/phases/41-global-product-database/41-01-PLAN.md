---
phase: 41-global-product-database
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/index.ts
  - src/hooks/useGlobalProducts.ts
  - src/hooks/useOpenFoodFacts.ts
  - src/services/openFoodFacts.ts
autonomous: true

must_haves:
  truths:
    - "Barcode lookup checks globalProducts first, then scannedProducts, then OFF API"
    - "Found OFF products are written back to globalProducts for cross-household caching"
    - "ScannedProducts still serves as household override layer"
  artifacts:
    - path: "src/types/index.ts"
      provides: "GlobalProduct type definition"
      contains: "interface GlobalProduct"
    - path: "src/hooks/useGlobalProducts.ts"
      provides: "Hook for global product lookups"
      exports: ["useGlobalProducts"]
    - path: "src/hooks/useOpenFoodFacts.ts"
      provides: "Refactored lookup with globalProducts in chain"
  key_links:
    - from: "src/hooks/useOpenFoodFacts.ts"
      to: "src/hooks/useGlobalProducts.ts"
      via: "import and call getGlobalProduct before OFF API"
      pattern: "getGlobalProduct"
    - from: "src/hooks/useOpenFoodFacts.ts"
      to: "globalProducts collection"
      via: "write-through after OFF API hit"
      pattern: "setDoc.*globalProducts"
---

<objective>
Create the GlobalProduct type, useGlobalProducts hook, and refactor the barcode lookup flow to check globalProducts (shared cross-household cache) before falling back to scannedProducts and OFF API. Products found via OFF API get written to globalProducts for future cross-household lookups.

Purpose: Foundation for shared product database - eliminates redundant OFF API calls across households
Output: GlobalProduct type, useGlobalProducts hook, refactored useOpenFoodFacts with new lookup order
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@src/types/index.ts
@src/hooks/useOpenFoodFacts.ts
@src/hooks/useScannedProducts.ts
@src/services/openFoodFacts.ts
@src/components/scanner/BarcodeScannerModal.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: GlobalProduct type and useGlobalProducts hook</name>
  <files>src/types/index.ts, src/hooks/useGlobalProducts.ts</files>
  <action>
1. Add GlobalProduct interface to src/types/index.ts (after ScannedProduct):
```typescript
export interface GlobalProduct {
  barcode: string;        // Also the document ID for O(1) lookup
  name: string;
  brand?: string;
  imageUrl?: string;
  categories?: string[];  // OFF categories_tags
  source: 'off' | 'manual' | 'bulk'; // How it was added
  createdAt: Date;
  updatedAt: Date;
}
```

2. Create src/hooks/useGlobalProducts.ts:
- NO real-time listener (unlike useScannedProducts). Use getDoc on demand.
- `getGlobalProduct(barcode: string): Promise<GlobalProduct | null>` - single doc lookup using barcode as document ID
- `setGlobalProduct(product: Omit<GlobalProduct, 'createdAt' | 'updatedAt'>): Promise<void>` - upsert using setDoc with merge:true
- Collection path: `globalProducts` (top-level, not under household)
- Import db from '../config/firebase'
- Use doc(db, 'globalProducts', barcode) for O(1) lookups (barcode IS the doc ID)
- Convert Firestore Timestamps to Date on read
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit` passes with no errors on the new files</verify>
  <done>GlobalProduct type exported from types/index.ts, useGlobalProducts hook exports getGlobalProduct and setGlobalProduct</done>
</task>

<task type="auto">
  <name>Task 2: Refactor useOpenFoodFacts lookup chain</name>
  <files>src/hooks/useOpenFoodFacts.ts</files>
  <action>
Refactor the lookup function in useOpenFoodFacts to implement the new lookup order:
1. globalProducts (shared cache) -> 2. scannedProducts (household override) -> 3. OFF API -> write to globalProducts

Specific changes to the `lookup` callback:
1. Import and call useGlobalProducts at hook level (not inside callback)
2. In lookup function, FIRST call `getGlobalProduct(barcode)`. If found, set source to 'global' and return.
3. THEN check scannedProducts cache via existing `getByBarcode(barcode)`. If found, return as 'cache' (existing behavior).
4. THEN call OFF API via `lookupBarcode(barcode)`. If found:
   - Write to globalProducts via `setGlobalProduct({ barcode, name, brand, imageUrl, categories, source: 'off' })`
   - ALSO still write to scannedProducts (existing behavior for household-level cache)
   - Return with source: 'off'
5. If not found anywhere, return source: 'none'

Update LookupResultWithSource to add 'global' to the source union type: `source: 'cache' | 'off' | 'none' | 'global'`

Do NOT change any component code - the BarcodeScannerModal and other consumers use the same hook interface, just with an additional possible source value.
  </action>
  <verify>`npx tsc --noEmit` passes. Manually verify the lookup chain order in the code: globalProducts -> scannedProducts -> OFF API -> write-through to globalProducts.</verify>
  <done>useOpenFoodFacts checks globalProducts first, falls back through scannedProducts and OFF API, and writes OFF results to globalProducts collection</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `npm run build` succeeds
- GlobalProduct interface exists in types/index.ts
- useGlobalProducts.ts exports getGlobalProduct and setGlobalProduct
- useOpenFoodFacts.ts lookup order: globalProducts -> scannedProducts -> OFF API
- OFF API hits write back to globalProducts via setGlobalProduct
</verification>

<success_criteria>
- Barcode lookup chain follows: globalProducts -> scannedProducts -> OFF API
- OFF API results are cached in globalProducts (cross-household)
- ScannedProducts still works as household-level override
- No breaking changes to BarcodeScannerModal or other consumers
- App builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/41-global-product-database/41-01-SUMMARY.md`
</output>

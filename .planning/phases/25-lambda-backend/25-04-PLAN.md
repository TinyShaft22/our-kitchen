---
phase: 25-lambda-backend
plan: 04
type: execute
wave: 2
depends_on: ["25-01", "25-02"]
files_modified:
  - our-kitchen-alexa/lambda/handlers/MealHandlers.js
  - our-kitchen-alexa/lambda/index.js
autonomous: true

must_haves:
  truths:
    - "User can ask 'what's for dinner' and hear meal names"
    - "User can ask for recipe and hear ingredients"
    - "If not linked, user is prompted for PIN before seeing meals"
    - "Lists are capped at 5 items with 'and X more'"
  artifacts:
    - path: "our-kitchen-alexa/lambda/handlers/MealHandlers.js"
      provides: "Meal browsing and recipe handlers"
      exports: ["BrowseMealsIntentHandler", "GetRecipeIntentHandler", "BrowseCategoryIntentHandler"]
  key_links:
    - from: "our-kitchen-alexa/lambda/handlers/MealHandlers.js"
      to: "our-kitchen-alexa/lambda/api/firebaseClient.js"
      via: "getMeals, getRecipe API calls"
      pattern: "firebaseClient\\.(getMeals|getRecipe)"
    - from: "our-kitchen-alexa/lambda/handlers/MealHandlers.js"
      to: "our-kitchen-alexa/lambda/handlers/HouseholdHandlers.js"
      via: "createPinPromptResponse for unlinked users"
      pattern: "createPinPromptResponse"
---

<objective>
Implement meal browsing and recipe handlers for voice interaction.

Purpose: Users need to ask about weekly meals ("what's for dinner") and get recipe details ("how do I make tacos"). These handlers fetch data from Firebase and format responses for voice.

Output: BrowseMealsIntentHandler, GetRecipeIntentHandler, BrowseCategoryIntentHandler registered and working.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/25-lambda-backend/25-CONTEXT.md
@.planning/phases/25-lambda-backend/25-RESEARCH.md
@.planning/phases/25-lambda-backend/25-02-SUMMARY.md
@our-kitchen-alexa/lambda/index.js
@our-kitchen-alexa/lambda/api/firebaseClient.js
@our-kitchen-alexa/lambda/util/sessionHelper.js
@our-kitchen-alexa/lambda/handlers/HouseholdHandlers.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create meal and recipe handlers</name>
  <files>
    our-kitchen-alexa/lambda/handlers/MealHandlers.js
  </files>
  <action>
Create handlers/MealHandlers.js with three handlers:

```javascript
/**
 * Meal Handlers
 * Browse meals, get recipe details, browse by category
 */
const Alexa = require('ask-sdk-core');
const { getMeals, getRecipe } = require('../api/firebaseClient');
const { isLinked, getHouseholdCode } = require('../util/sessionHelper');
const { createPinPromptResponse } = require('./HouseholdHandlers');

/**
 * BrowseMealsIntentHandler
 * "What's for dinner?" / "What meals are planned?"
 *
 * Per CONTEXT.md:
 * - Names only, cap at 5 items
 * - "and X more" if more than 5
 */
const BrowseMealsIntentHandler = {
  canHandle(handlerInput) {
    return Alexa.getRequestType(handlerInput.requestEnvelope) === 'IntentRequest'
      && Alexa.getIntentName(handlerInput.requestEnvelope) === 'BrowseMealsIntent';
  },

  async handle(handlerInput) {
    // Check if linked
    if (!isLinked(handlerInput)) {
      return createPinPromptResponse(handlerInput, 'BrowseMeals');
    }

    const householdCode = getHouseholdCode(handlerInput);

    try {
      const result = await getMeals(householdCode);
      const meals = result.meals || [];

      if (meals.length === 0) {
        return handlerInput.responseBuilder
          .speak("Your weekly plan is empty. Add meals in the app to get started.")
          .reprompt("What else would you like to do?")
          .getResponse();
      }

      // Cap at 5 items per CONTEXT.md
      const mealNames = meals.slice(0, 5).map(m => m.name);
      const remaining = meals.length - 5;

      let speakOutput = `Your meals are: ${formatList(mealNames)}`;
      if (remaining > 0) {
        speakOutput += `, and ${remaining} more`;
      }
      speakOutput += ". Which one do you want to know more about?";

      // Store meals in session for follow-up
      const sessionAttributes = handlerInput.attributesManager.getSessionAttributes();
      sessionAttributes.lastMealList = meals;
      handlerInput.attributesManager.setSessionAttributes(sessionAttributes);

      return handlerInput.responseBuilder
        .speak(speakOutput)
        .reprompt("Which meal would you like to see?")
        .getResponse();

    } catch (error) {
      console.log('Browse meals error:', error.message);
      return handlerInput.responseBuilder
        .speak("I'm having trouble getting your meals right now. Try again in a moment.")
        .reprompt("What would you like to do?")
        .getResponse();
    }
  }
};

/**
 * GetRecipeIntentHandler
 * "Show me the recipe for {MealName}" / "What's in {MealName}?"
 *
 * Per CONTEXT.md:
 * - Ingredients first, then ask "Ready for the steps?"
 */
const GetRecipeIntentHandler = {
  canHandle(handlerInput) {
    return Alexa.getRequestType(handlerInput.requestEnvelope) === 'IntentRequest'
      && Alexa.getIntentName(handlerInput.requestEnvelope) === 'GetRecipeIntent';
  },

  async handle(handlerInput) {
    // Check if linked
    if (!isLinked(handlerInput)) {
      return createPinPromptResponse(handlerInput, 'GetRecipe');
    }

    const householdCode = getHouseholdCode(handlerInput);
    const slots = handlerInput.requestEnvelope.request.intent.slots;
    const mealNameSlot = slots.MealName;

    // Get resolved value (handles synonyms) or raw value
    const mealName = getResolvedSlotValue(mealNameSlot) || mealNameSlot?.value;

    if (!mealName) {
      return handlerInput.responseBuilder
        .speak("Which recipe would you like? Try saying the meal name.")
        .reprompt("What meal do you want the recipe for?")
        .getResponse();
    }

    try {
      // Find meal ID from session or search
      const sessionAttributes = handlerInput.attributesManager.getSessionAttributes();
      const lastMealList = sessionAttributes.lastMealList || [];

      // Try to match meal name (case-insensitive partial match)
      const matchedMeal = lastMealList.find(m =>
        m.name.toLowerCase().includes(mealName.toLowerCase()) ||
        mealName.toLowerCase().includes(m.name.toLowerCase())
      );

      if (!matchedMeal) {
        // TODO: In future, could search Firebase for meal by name
        return handlerInput.responseBuilder
          .speak(`I couldn't find ${mealName}. Try asking what's for dinner first, then pick a meal.`)
          .reprompt("What would you like to do?")
          .getResponse();
      }

      const result = await getRecipe(householdCode, matchedMeal.id);

      if (!result || !result.name) {
        return handlerInput.responseBuilder
          .speak(`Hmm, I can't find that recipe. Try asking what's for dinner first.`)
          .reprompt("What would you like to do?")
          .getResponse();
      }

      // Build ingredients list (cap at 7 for voice)
      const ingredients = result.ingredients || [];
      const ingredientNames = ingredients.slice(0, 7).map(i => i.name);
      const remainingIngredients = ingredients.length - 7;

      let speakOutput = `For ${result.name}, you'll need: ${formatList(ingredientNames)}`;
      if (remainingIngredients > 0) {
        speakOutput += `, and ${remainingIngredients} more items`;
      }
      speakOutput += ". Ready for the cooking steps?";

      // Store recipe in session for cooking mode
      sessionAttributes.currentRecipe = result;
      sessionAttributes.currentRecipeStep = 0;
      handlerInput.attributesManager.setSessionAttributes(sessionAttributes);

      return handlerInput.responseBuilder
        .speak(speakOutput)
        .reprompt("Say yes to hear the cooking steps, or ask about another meal.")
        .getResponse();

    } catch (error) {
      console.log('Get recipe error:', error.message);
      return handlerInput.responseBuilder
        .speak("I'm having trouble getting that recipe right now. Try again in a moment.")
        .reprompt("What would you like to do?")
        .getResponse();
    }
  }
};

/**
 * BrowseCategoryIntentHandler
 * "Show me cookies" / "What baking recipes do we have?"
 *
 * Note: This is a placeholder - full implementation needs category search endpoint
 */
const BrowseCategoryIntentHandler = {
  canHandle(handlerInput) {
    return Alexa.getRequestType(handlerInput.requestEnvelope) === 'IntentRequest'
      && Alexa.getIntentName(handlerInput.requestEnvelope) === 'BrowseCategoryIntent';
  },

  async handle(handlerInput) {
    // Check if linked
    if (!isLinked(handlerInput)) {
      return createPinPromptResponse(handlerInput, 'BrowseCategory');
    }

    const slots = handlerInput.requestEnvelope.request.intent.slots;
    const category = slots.Category?.value;

    // For now, redirect to browse all meals
    // TODO: Add category search endpoint to Cloud Functions
    return handlerInput.responseBuilder
      .speak(`Looking for ${category || 'recipes'}. Let me show you what's planned this week instead.`)
      .reprompt("What would you like to do?")
      .addDelegateDirective({
        name: 'BrowseMealsIntent',
        confirmationStatus: 'NONE',
        slots: {}
      })
      .getResponse();
  }
};

/**
 * Format a list for natural speech
 * ["a", "b", "c"] -> "a, b, and c"
 */
function formatList(items) {
  if (items.length === 0) return '';
  if (items.length === 1) return items[0];
  if (items.length === 2) return `${items[0]} and ${items[1]}`;
  const last = items[items.length - 1];
  const rest = items.slice(0, -1);
  return `${rest.join(', ')}, and ${last}`;
}

/**
 * Get resolved slot value (handles entity resolution)
 */
function getResolvedSlotValue(slot) {
  if (!slot) return null;

  // Check for entity resolution
  const resolutions = slot.resolutions?.resolutionsPerAuthority;
  if (resolutions && resolutions.length > 0) {
    const resolution = resolutions[0];
    if (resolution.status?.code === 'ER_SUCCESS_MATCH') {
      return resolution.values[0]?.value?.name;
    }
  }

  return null;
}

module.exports = {
  BrowseMealsIntentHandler,
  GetRecipeIntentHandler,
  BrowseCategoryIntentHandler
};
```
  </action>
  <verify>
Run `node -e "require('./handlers/MealHandlers.js')"` from lambda directory - no syntax errors.
Verify exports: BrowseMealsIntentHandler, GetRecipeIntentHandler, BrowseCategoryIntentHandler.
  </verify>
  <done>
MealHandlers.js created with BrowseMeals (weekly plan), GetRecipe (ingredients + prep for steps), and BrowseCategory (placeholder).
  </done>
</task>

<task type="auto">
  <name>Task 2: Register meal handlers in index.js</name>
  <files>
    our-kitchen-alexa/lambda/index.js
  </files>
  <action>
Update index.js to import and register meal handlers:

**Add import:**
```javascript
const { BrowseMealsIntentHandler, GetRecipeIntentHandler, BrowseCategoryIntentHandler } = require('./handlers/MealHandlers');
```

**Add to request handlers (before built-in handlers):**
```javascript
exports.handler = Alexa.SkillBuilders.custom()
    .addRequestHandlers(
        LaunchRequestHandler,
        LinkHouseholdIntentHandler,
        BrowseMealsIntentHandler,      // Add
        GetRecipeIntentHandler,         // Add
        BrowseCategoryIntentHandler,    // Add
        HelloWorldIntentHandler,
        HelpIntentHandler,
        CancelAndStopIntentHandler,
        FallbackIntentHandler,
        SessionEndedRequestHandler
    )
    // ... rest unchanged
```

**Order matters:** Intent handlers are checked in order. Custom intents should come before built-in handlers.
  </action>
  <verify>
Run `node -e "require('./index.js')"` from lambda directory - no syntax errors.
Verify all three meal handlers are registered.
  </verify>
  <done>
BrowseMealsIntentHandler, GetRecipeIntentHandler, BrowseCategoryIntentHandler registered in index.js.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. handlers/MealHandlers.js exists with 3 handlers
2. index.js imports and registers all 3 meal handlers
3. `node -e "require('./index.js')"` runs without errors
4. BrowseMealsIntent prompts for PIN if not linked
5. BrowseMealsIntent returns meal names (max 5) with "and X more"
6. GetRecipeIntent returns ingredients and asks about steps
7. Casual friendly error messages
</verification>

<success_criteria>
- BrowseMealsIntentHandler fetches weekly meals, formats for voice (5 max)
- GetRecipeIntentHandler fetches recipe, reads ingredients, preps for cooking mode
- BrowseCategoryIntentHandler exists (placeholder for future)
- Unlinked users get PIN prompt with pending action stored
- Casual friendly tone in all responses
- Error handling with helpful messages
</success_criteria>

<output>
After completion, create `.planning/phases/25-lambda-backend/25-04-SUMMARY.md`
</output>

---
phase: 25-lambda-backend
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - our-kitchen-alexa/lambda/package.json
  - our-kitchen-alexa/lambda/index.js
  - our-kitchen-alexa/lambda/api/firebaseClient.js
  - our-kitchen-alexa/lambda/interceptors/RequestInterceptors.js
  - our-kitchen-alexa/lambda/interceptors/ResponseInterceptors.js
  - our-kitchen-alexa/lambda/util/sessionHelper.js
autonomous: true

must_haves:
  truths:
    - "Lambda loads household state from DynamoDB on every request"
    - "Lambda auto-saves persistent attributes after every response"
    - "Lambda can make HTTP calls to Cloud Functions with timeout"
    - "Session helpers provide easy access to household linking state"
  artifacts:
    - path: "our-kitchen-alexa/lambda/api/firebaseClient.js"
      provides: "HTTP client for Cloud Functions"
      exports: ["getMeals", "getRecipe", "getGroceryList", "addGroceryItem", "removeGroceryItem", "verifyPin"]
    - path: "our-kitchen-alexa/lambda/interceptors/RequestInterceptors.js"
      provides: "Request interceptor for loading household state"
      exports: ["LoadHouseholdInterceptor", "LogRequestInterceptor"]
    - path: "our-kitchen-alexa/lambda/interceptors/ResponseInterceptors.js"
      provides: "Response interceptor for auto-saving attributes"
      exports: ["SavePersistentAttributesInterceptor"]
    - path: "our-kitchen-alexa/lambda/util/sessionHelper.js"
      provides: "Session attribute helpers"
      exports: ["isLinked", "getHouseholdCode", "setPendingAction", "getPendingAction", "clearPendingAction"]
  key_links:
    - from: "our-kitchen-alexa/lambda/index.js"
      to: "DynamoDB persistence adapter"
      via: "SkillBuilder.withPersistenceAdapter"
      pattern: "withPersistenceAdapter\\(persistenceAdapter\\)"
    - from: "our-kitchen-alexa/lambda/index.js"
      to: "our-kitchen-alexa/lambda/interceptors/RequestInterceptors.js"
      via: "addRequestInterceptors"
      pattern: "addRequestInterceptors.*LoadHouseholdInterceptor"
---

<objective>
Set up Lambda core infrastructure: DynamoDB persistence, request/response interceptors, and HTTP client for Cloud Functions.

Purpose: Handlers need shared infrastructure for persistence (household linking) and API access (Firebase data). This foundation enables all subsequent handler development.

Output: Lambda with persistence adapter, interceptors registered, and HTTP client ready.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/25-lambda-backend/25-CONTEXT.md
@.planning/phases/25-lambda-backend/25-RESEARCH.md
@our-kitchen-alexa/lambda/index.js
@our-kitchen-alexa/lambda/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create HTTP client</name>
  <files>
    our-kitchen-alexa/lambda/package.json
    our-kitchen-alexa/lambda/api/firebaseClient.js
  </files>
  <action>
**Install dependencies** in our-kitchen-alexa/lambda/:
```bash
cd our-kitchen-alexa/lambda && npm install axios ask-sdk-dynamodb-persistence-adapter
```

Note: aws-sdk is already available in Lambda runtime, no need to install.

**Create api/firebaseClient.js** - Centralized HTTP client:

```javascript
const axios = require('axios');

// Cloud Functions base URL - our-kitchen-prod is the Firebase project
const CLOUD_FUNCTIONS_BASE = 'https://us-central1-our-kitchen-prod.cloudfunctions.net';
const API_KEY = 'ourkitchen2024';
const DEFAULT_TIMEOUT = 5000; // 5 seconds - leaves buffer for Alexa's 8s timeout

const client = axios.create({
  baseURL: CLOUD_FUNCTIONS_BASE,
  timeout: DEFAULT_TIMEOUT,
  headers: {
    'Content-Type': 'application/json',
    'X-API-Key': API_KEY
  }
});

async function verifyPin(pin) {
  const response = await client.post('/verifyPin', { pin });
  return response.data;
}

async function getMeals(householdCode) {
  const response = await client.get('/meals', {
    params: { householdCode }
  });
  return response.data;
}

async function getRecipe(householdCode, mealId) {
  const response = await client.get('/recipe', {
    params: { householdCode, mealId }
  });
  return response.data;
}

async function getGroceryList(householdCode) {
  const response = await client.get('/groceryList', {
    params: { householdCode }
  });
  return response.data;
}

async function addGroceryItem(householdCode, item, quantity) {
  const response = await client.post('/addGroceryItem', {
    householdCode,
    item,
    quantity
  });
  return response.data;
}

async function removeGroceryItem(householdCode, item) {
  const response = await client.post('/removeGroceryItem', {
    householdCode,
    item
  });
  return response.data;
}

module.exports = {
  verifyPin,
  getMeals,
  getRecipe,
  getGroceryList,
  addGroceryItem,
  removeGroceryItem
};
```
  </action>
  <verify>
Run `cd our-kitchen-alexa/lambda && npm install` - dependencies install without errors.
Verify api/firebaseClient.js exports all 6 functions.
  </verify>
  <done>
axios and persistence adapter installed. firebaseClient.js created with all 6 API methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create interceptors and session helpers</name>
  <files>
    our-kitchen-alexa/lambda/interceptors/RequestInterceptors.js
    our-kitchen-alexa/lambda/interceptors/ResponseInterceptors.js
    our-kitchen-alexa/lambda/util/sessionHelper.js
  </files>
  <action>
**Create interceptors/RequestInterceptors.js**:

```javascript
/**
 * Request Interceptors
 * Run before every handler to prepare context
 */

/**
 * LogRequestInterceptor
 * Logs incoming request for debugging
 */
const LogRequestInterceptor = {
  async process(handlerInput) {
    const requestType = handlerInput.requestEnvelope.request.type;
    const intentName = handlerInput.requestEnvelope.request.intent?.name || 'N/A';
    console.log(`Request: ${requestType} | Intent: ${intentName}`);
  }
};

/**
 * LoadHouseholdInterceptor
 * Loads persistent attributes and makes household state available in session
 */
const LoadHouseholdInterceptor = {
  async process(handlerInput) {
    const attributesManager = handlerInput.attributesManager;

    try {
      const persistentAttributes = await attributesManager.getPersistentAttributes() || {};

      // Make household code available in session attributes for easy access
      const sessionAttributes = attributesManager.getSessionAttributes() || {};
      sessionAttributes.householdCode = persistentAttributes.householdCode || null;
      sessionAttributes.isLinked = !!persistentAttributes.householdCode;
      attributesManager.setSessionAttributes(sessionAttributes);

      console.log('Loaded household state:', {
        householdCode: persistentAttributes.householdCode ? '***' : null,
        isLinked: !!persistentAttributes.householdCode
      });
    } catch (error) {
      // If persistence fails, continue with unlinked state
      console.error('Failed to load persistent attributes:', error.message);
      const sessionAttributes = attributesManager.getSessionAttributes() || {};
      sessionAttributes.householdCode = null;
      sessionAttributes.isLinked = false;
      attributesManager.setSessionAttributes(sessionAttributes);
    }
  }
};

module.exports = {
  LogRequestInterceptor,
  LoadHouseholdInterceptor
};
```

**Create interceptors/ResponseInterceptors.js**:

```javascript
/**
 * Response Interceptors
 * Run after every handler to cleanup/save
 */

/**
 * SavePersistentAttributesInterceptor
 * Auto-saves persistent attributes after every response
 * Only saves if attributes were modified (dirty flag pattern)
 */
const SavePersistentAttributesInterceptor = {
  async process(handlerInput) {
    const sessionAttributes = handlerInput.attributesManager.getSessionAttributes() || {};

    // Only save if we've marked attributes as dirty
    if (sessionAttributes.persistentAttributesDirty) {
      try {
        await handlerInput.attributesManager.savePersistentAttributes();
        console.log('Saved persistent attributes');

        // Clear dirty flag
        sessionAttributes.persistentAttributesDirty = false;
        handlerInput.attributesManager.setSessionAttributes(sessionAttributes);
      } catch (error) {
        console.error('Failed to save persistent attributes:', error.message);
      }
    }
  }
};

module.exports = {
  SavePersistentAttributesInterceptor
};
```

**Create util/sessionHelper.js**:

```javascript
/**
 * Session Attribute Helpers
 * Convenience functions for common session operations
 */

function isLinked(handlerInput) {
  const sessionAttributes = handlerInput.attributesManager.getSessionAttributes();
  return sessionAttributes.isLinked === true;
}

function getHouseholdCode(handlerInput) {
  const sessionAttributes = handlerInput.attributesManager.getSessionAttributes();
  return sessionAttributes.householdCode;
}

function setPendingAction(handlerInput, action, params = {}) {
  const sessionAttributes = handlerInput.attributesManager.getSessionAttributes();
  sessionAttributes.pendingAction = action;
  sessionAttributes.pendingParams = params;
  handlerInput.attributesManager.setSessionAttributes(sessionAttributes);
}

function getPendingAction(handlerInput) {
  const sessionAttributes = handlerInput.attributesManager.getSessionAttributes();
  return {
    action: sessionAttributes.pendingAction,
    params: sessionAttributes.pendingParams || {}
  };
}

function clearPendingAction(handlerInput) {
  const sessionAttributes = handlerInput.attributesManager.getSessionAttributes();
  sessionAttributes.pendingAction = null;
  sessionAttributes.pendingParams = null;
  handlerInput.attributesManager.setSessionAttributes(sessionAttributes);
}

/**
 * Mark persistent attributes as needing save
 * Call this after modifying persistent attributes
 */
function markPersistentDirty(handlerInput) {
  const sessionAttributes = handlerInput.attributesManager.getSessionAttributes();
  sessionAttributes.persistentAttributesDirty = true;
  handlerInput.attributesManager.setSessionAttributes(sessionAttributes);
}

module.exports = {
  isLinked,
  getHouseholdCode,
  setPendingAction,
  getPendingAction,
  clearPendingAction,
  markPersistentDirty
};
```
  </action>
  <verify>
Verify all three files exist with correct exports:
- interceptors/RequestInterceptors.js exports LogRequestInterceptor, LoadHouseholdInterceptor
- interceptors/ResponseInterceptors.js exports SavePersistentAttributesInterceptor
- util/sessionHelper.js exports isLinked, getHouseholdCode, setPendingAction, getPendingAction, clearPendingAction, markPersistentDirty
  </verify>
  <done>
Request/response interceptors created. Session helper utilities created with 6 functions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Configure persistence adapter and register interceptors</name>
  <files>
    our-kitchen-alexa/lambda/index.js
  </files>
  <action>
Update index.js to add:
1. DynamoDB persistence adapter with device ID partition key
2. Request interceptors (LogRequest, LoadHousehold)
3. Response interceptor (SavePersistentAttributes)

**Key points:**
- Use device ID (not user ID) for partition key - survives Amazon account changes
- DynamoDB table name comes from environment variable (Alexa-Hosted provides this)
- Keep existing handlers (LaunchRequest, Help, Cancel, etc.)

Update the file to look like this (preserving existing handler code):

```javascript
/**
 * Our Kitchen - Alexa Skill Handler
 *
 * This skill helps manage meals, recipes, and grocery lists using voice commands.
 * Built with ASK SDK v2 for Node.js.
 */
const Alexa = require('ask-sdk-core');
const AWS = require('aws-sdk');
const { DynamoDbPersistenceAdapter } = require('ask-sdk-dynamodb-persistence-adapter');

// Import interceptors
const { LogRequestInterceptor, LoadHouseholdInterceptor } = require('./interceptors/RequestInterceptors');
const { SavePersistentAttributesInterceptor } = require('./interceptors/ResponseInterceptors');

/**
 * Device ID partition key generator
 * Uses device ID instead of user ID for persistence
 * Device ID is stable across Amazon account changes
 */
function deviceIdPartitionKeyGenerator(requestEnvelope) {
  const deviceId = requestEnvelope.context?.System?.device?.deviceId;
  if (!deviceId) {
    throw new Error('Cannot get device ID from request envelope');
  }
  return deviceId;
}

/**
 * DynamoDB Persistence Adapter
 * Alexa-Hosted Skills provide table name and region via environment variables
 */
const persistenceAdapter = new DynamoDbPersistenceAdapter({
  tableName: process.env.DYNAMODB_PERSISTENCE_TABLE_NAME,
  createTable: false,
  partitionKeyGenerator: deviceIdPartitionKeyGenerator,
  dynamoDBClient: new AWS.DynamoDB({
    apiVersion: 'latest',
    region: process.env.DYNAMODB_PERSISTENCE_REGION
  })
});

// ... (keep all existing handlers: LaunchRequestHandler, HelloWorldIntentHandler, etc.)

/**
 * Skill entry point
 * Routes all requests to the appropriate handlers
 */
exports.handler = Alexa.SkillBuilders.custom()
    .addRequestHandlers(
        LaunchRequestHandler,
        HelloWorldIntentHandler,
        HelpIntentHandler,
        CancelAndStopIntentHandler,
        FallbackIntentHandler,
        SessionEndedRequestHandler
    )
    .addErrorHandlers(
        ErrorHandler
    )
    .addRequestInterceptors(
        LogRequestInterceptor,
        LoadHouseholdInterceptor
    )
    .addResponseInterceptors(
        SavePersistentAttributesInterceptor
    )
    .withPersistenceAdapter(persistenceAdapter)
    .withCustomUserAgent('our-kitchen/v2.0')
    .lambda();
```

Update the ErrorHandler to use casual friendly tone per CONTEXT.md:

```javascript
const ErrorHandler = {
    canHandle() {
        return true;
    },
    handle(handlerInput, error) {
        console.log(`Error: ${error.message}`);
        console.log(`Stack: ${error.stack}`);

        let speakOutput = "Hmm, something went wrong. ";

        // Customize based on error type
        if (error.message.includes('timeout') || error.message.includes('ECONNREFUSED') || error.message.includes('ETIMEDOUT')) {
            speakOutput = "I'm having trouble connecting to your kitchen right now. Try again in a moment.";
        } else {
            speakOutput += "Please try again.";
        }

        return handlerInput.responseBuilder
            .speak(speakOutput)
            .reprompt("What would you like to do?")
            .getResponse();
    }
};
```
  </action>
  <verify>
Run `cd our-kitchen-alexa/lambda && node -e "require('./index.js')"` - should not throw syntax errors.
Verify index.js imports all interceptors and configures persistence adapter.
  </verify>
  <done>
Lambda configured with DynamoDB persistence adapter (device ID partition key), request interceptors (log + load household), and response interceptor (auto-save). Error handler updated with friendly tone.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm install` in lambda/ completes successfully
2. axios and ask-sdk-dynamodb-persistence-adapter in package.json dependencies
3. api/firebaseClient.js exists with 6 API methods
4. interceptors/RequestInterceptors.js exports LogRequestInterceptor, LoadHouseholdInterceptor
5. interceptors/ResponseInterceptors.js exports SavePersistentAttributesInterceptor
6. util/sessionHelper.js exports 6 helper functions
7. index.js uses persistence adapter, request interceptors, response interceptor
8. `node -e "require('./index.js')"` runs without errors
</verification>

<success_criteria>
- Dependencies installed (axios, ask-sdk-dynamodb-persistence-adapter)
- HTTP client ready to call 6 Cloud Functions endpoints
- Persistence adapter configured with device ID partition key
- Request interceptors load household state on every request
- Response interceptor auto-saves persistent attributes
- Session helpers provide clean API for handlers
- Error handler uses casual friendly tone
</success_criteria>

<output>
After completion, create `.planning/phases/25-lambda-backend/25-02-SUMMARY.md`
</output>
